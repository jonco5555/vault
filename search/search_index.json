{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Vault"},{"location":"#public-github-repository-link","title":"Public Github Repository link","text":"<p>https://github.com/jonco5555/vault</p>"},{"location":"#public-documentation-link-highly-recommended-instead-of-reading-the-pdf","title":"Public Documentation link - Highly recommended instead of reading the pdf","text":"<p>Contains the same content as this pdf, but more convenient.</p> <p>https://jonco5555.github.io/vault</p>"},{"location":"#the-problem-space","title":"The Problem space","text":"<p>In modern digital systems, protecting sensitive information such as cryptographic keys, credentials, and personal data is a critical challenge. Secrets are often stored and accessed remotely, which raises the risk that a single server compromise can expose the entire dataset. At the same time, authorized users must be able to reliably retrieve these secrets without excessive complexity or performance overhead. This tension between security, availability, and usability defines the core problem space.</p> <p>The state of the art in secure storage systems has made significant progress in mitigating these risks, but most conventional approaches still rely on a central trusted server or service. Such single-trust models introduce a single point of failure: once breached, all stored secrets become vulnerable. Even advanced password hashing and encrypted storage techniques cannot fully eliminate this dependency. As a result, current solutions remain exposed to insider threats, server breaches, and large-scale data leaks.</p>"},{"location":"#our-solution-the-vault","title":"Our Solution - The Vault","text":"<p>Our project introduces a secure digital secret manager that we call <code>Vault</code>.</p> <p>The <code>Vault</code> is designed to securely store and retrieve sensitive secrets on a remote server. The product combines multiple security primitives \u2014 TLS, SRP authentication, threshold cryptography, and end-to-end encryption \u2014 to create a solution where no single server can compromise a user\u2019s data. At the core of the design, secrets are encrypted by the user before leaving their device, stored only in encrypted form by the manager, and can only be reconstructed through cooperation between multiple share-servers and the user. This ensures that even if attackers gain partial control over the infrastructure, confidentiality of the secrets is preserved.</p> <p>To support these guarantees, the system architecture introduces several coordinated services:</p> <ul> <li><code>Manager</code>: Orchestrates all operations, including registration, storage, and retrieval.</li> <li><code>Bootstrap</code>: Generates cryptographic shares and is immediately destroyed to reduce the attack surface.</li> <li><code>ShareServer</code>: Each holds part of the decryption capability, requiring collaboration to restore user secrets.</li> <li><code>User</code>: Communicates with the system over TLS and authenticates via SRP, ensuring resilience against replay and impersonation.</li> </ul> <p>Together, these components form a robust product that addresses the challenges of secure remote secret management.</p>"},{"location":"#threat-model","title":"Threat model","text":"<p>We assume a powerful attacker with the following capabilities:</p> <ol> <li>Eavesdropping and Tampering: The attacker can intercept, replay, and modify network traffic between the user, manager, bootstrap, and share servers.</li> <li>Replay and Impersonation Attempts: The attacker may try to impersonate the user or replay old authentication messages to trick the system.</li> <li>Compromised Servers: The attacker may compromise one or several share servers or even the manager service.</li> <li>Malicious Bootstrap: The bootstrap service could be compromised during setup. This risk is mitigated by its short lifetime \u2014 it is created for key generation and immediately destroyed.</li> </ol> <p>However, we assume that:</p> <ol> <li>The cryptographic primitives (TLS, SRP, asymmetric encryption, threshold cryptography) are secure when used correctly.</li> <li>Not all share servers and the user are compromised simultaneously \u2014 at least one share remains honest.</li> <li>The user\u2019s end-to-end encryption key and SRP password are not leaked outside their device.</li> <li>Docker is only a convenience layer; in real deployments, services would run on isolated servers with strong operational security.</li> <li>The manager is not compromised during the user registration phase, otherwise it could send malicious public keys to the bootstrap.</li> </ol>"},{"location":"#design-motivation","title":"Design Motivation","text":"<p>Given this attacker model, the design addresses the threats as follows:</p> <ol> <li>TLS for all communication: Protects against eavesdropping and tampering on the network, ensuring confidentiality and integrity of traffic between all services.</li> <li>SRP authentication: Protects against replay attacks and password theft, since the password is never transmitted nor derivable from intercepted data. Even a compromised manager cannot recover the user\u2019s password.</li> <li>Threshold cryptography with missing user share: Ensures that neither the manager nor any subset of share servers can decrypt secrets on their own. The user\u2019s cooperation is always required to complete decryption, preserving end-to-end security even if some servers are compromised.</li> <li>Short-lived bootstrap service: Limits exposure of the most sensitive operation \u2014 key generation. By destroying the bootstrap immediately after setup, the attack surface is minimized.</li> <li>End-to-end encryption of shares: Guarantees that shares are only usable by their intended recipients (user and share servers). The manager cannot read or misuse them.</li> </ol>"},{"location":"advanced_details/","title":"Advanced Implementation Details","text":""},{"location":"advanced_details/#secure-communication-via-grpc-over-tls","title":"Secure Communication via gRPC over TLS","text":"<p>All communication between the system components is performed using gRPC, which provides a high-performance and structured RPC framework. To ensure confidentiality and integrity of messages exchanged between the user, manager, bootstrap, and share servers, we run gRPC over TLS. This combination guarantees that all remote procedure calls are both authenticated and encrypted, protecting against eavesdropping, tampering, and man-in-the-middle attacks while maintaining efficient inter-service communication.</p> <p>When each service is launched, it generates its own TLS certificate signed by a self-signed CA that every service knows both its public and private keys. Each service therefore possesses its own private and public key pair, allowing it to authenticate and encrypt communications with other services. While this approach is not fully secure for a production environment, it effectively demonstrates the concept of mutual TLS and encrypted gRPC communication without adding unnecessary complexity. This design choice allows us to focus on the core functionality and security mechanisms of the password manager system while still illustrating encrypted communication between components. The CA keys are a part of the docker image of every component.</p> <p>We use <code>cryptography</code> package and <code>RSA</code>. Reference:  <code>vault/crypto/certs.py</code>.</p>"},{"location":"advanced_details/#end-to-end-encryption-of-secret-shares","title":"End-to-End Encryption of Secret Shares","text":"<p>To ensure that secret shares are never exposed in plaintext outside their intended destination, our system employs an end-to-end encryption mechanism during the bootstrap phase.</p> <p>Upon creation, every share server generates its own asymmetric key pair and transmits its public key to the manager as part of the <code>SetupUnit</code> registration process. The manager maintains these public keys for future use but never stores or handles the corresponding private keys.</p> <p>During user registration, the bootstrap service receives the public keys of the active share servers and the user from the manager. Then before distribution, it encrypts each share with the corresponding public key. This guarantees that only the target recipient, holding the matching private key, can decrypt its assigned share.</p> <p>This design achieves true end-to-end encryption: the bootstrap service never transmits raw shares, the manager never has the ability to decrypt them, and only the intended recipients can access their respective shares.</p> <p>We use <code>pynacl</code> package and <code>nacl.public.SealedBox</code>. Reference:  <code>vault/crypto/asymmetric.py</code>.</p>"},{"location":"advanced_details/#threshold-cryptography","title":"Threshold Cryptography","text":"<p>Threshold cryptography means a message can be easily encrypted using a simple public key, but the decryption key is divided into n shares, where at least t of them are required to reconstruct the original secret.</p> <p>To generate encryption key and decryption shares, we use threshold-crypto package, that offers ElGamal-based threshold cryptography. This package is using a hybrid approach using <code>pynacl</code> for symmetric encryption and <code>PyCryptodome</code> for ECC operations, therefore there are no limitations regarding the size of the secret. The integrity of a message is secured using the AE-scheme, meaning changes to some parts of the ciphertext, to partial decryptions or even dishonest share owners can be detected.</p> <p>Reference:  <code>vault/crypto/threshold.py</code>.</p>"},{"location":"advanced_details/#system-setup-process","title":"System Setup Process","text":"<p>In our system, the generation of secret shares requires a temporary \u201cbootstrap\u201d environment to securely create and handle sensitive data. A key challenge is that this bootstrap Docker container must be terminated immediately after completing its task, to minimize exposure and prevent potential compromise of the secrets.</p> <p>To address this, we designed a setup architecture composed of a <code>SetupMaster</code> and multiple <code>SetupUnits</code>. The master orchestrates the lifecycle of containers, spawning setup units as needed to generate shares, and ensures that each unit registers with the master at startup and unregisters before termination. This design guarantees isolation, scalability, and secure handling of secret shares.</p> <p>Moreover, this infrastructure allows us to send critical data on setup, such as public E2E keys that we will see later, as well as the complement\u2019s new address so the manager will be able to communicate with it. Building on this infrastructure, we also used the same master-unit architecture to orchestrate the long-lived share servers. By leveraging the established orchestration system, we can manage server deployment, registration, and coordination in a consistent and secure manner, reducing operational complexity while maintaining robust control over the threshold cryptography environment. The following is a diagram of the setup flow, defined in the <code>setup.proto</code> file and implemented in <code>setup_master.py</code> and <code>setup_unit.py</code> files:</p> <p></p>"},{"location":"advanced_details/#authentication","title":"Authentication","text":"<p>In our project, we adopted the Secure Remote Password (SRP) protocol as the primary authentication mechanism. SRP is a password-authenticated key exchange (PAKE) that allows a client and server to establish a shared session key without ever transmitting the password itself. The protocol begins with a registration stage, where the client generates a password verifier and salt, which are then stored by the server. During the authentication stage, the client and server exchange public values derived from their secrets, process the salt and verifier, and independently compute a session key that only matches if the password is correct. We implemented this flow over gRPC using its streaming feature, enabling a sequence of secure message exchanges between the client and server during authentication.</p> <p>SRP Reference: T. Wu, \u201cThe Secure Remote Password Protocol,\u201d in Proc. Internet Society Network and Distributed System Security Symposium (NDSS), San Diego, CA, USA, 1998.</p> <p>The following is a diagram of the registration and authentication flow, defined in the <code>vault.proto</code> file and the main interface of the Manager gRPC service. The implementation is in <code>authentication.py</code>, <code>manager.py</code> and <code>user.py</code> files:</p> <p></p> <p>We designed our product such that every application request (Store secret and Retrieve secret) will have to re-authenticate using the selected password. The \u201cAppRequest\u201d and \u201cAppResponse\u201d from the diagram above are a wrapper for all possible grpc application requests messages.</p> <p>This design directly addresses our threat model: even if an attacker compromises the server database, they cannot perform offline password guessing, and even if traffic is observed, no password is leaked to the adversary.</p>"},{"location":"advanced_details/#using-both-srp-and-tls","title":"Using both SRP and TLS","text":"<p>TLS protects the channel, SRP protects the password. TLS and SRP address different aspects of secure communication. TLS ensures confidentiality and integrity of the data transmitted between client and server, protecting against eavesdropping and tampering. SRP, on the other hand, is a password-authenticated key exchange protocol that allows mutual authentication without ever transmitting the password and prevents offline dictionary attacks even if the server is compromised. In our design, we combine TLS with SRP to benefit from both: TLS provides a well-established secure transport layer, while SRP adds strong password-based authentication and resistance against server-side credential compromise. Together, they create a more robust and layered security model.</p>"},{"location":"design_implementation/","title":"Design Implementation","text":""},{"location":"design_implementation/#overview","title":"Overview","text":"<p>The project consists of several interacting components designed to securely store and retrieve user secrets: </p> <p>The <code>User</code> is the client of the password manager, responsible for registering and authenticating with the system using a password. The user holds the final share of his secret, ensuring that only him can fully reconstruct and access their sensitive data.</p> <p>The <code>Manager</code> service orchestrates all server-side components. It handles requests from users, coordinates the <code>Bootstrap</code> and <code>Share Servers</code>, and maintains the system state. The manager ensures services are correctly registered, manages Docker lifecycles for short-lived containers, and enforces secure communication over TLS.</p> <p><code>Share Servers</code> are long-lived server-side components that each hold a portion of a user\u2019s secret. They cooperate to perform threshold cryptography operations but cannot individually reconstruct the secret. These services are orchestrated by the manager to provide controlled access to user data.</p> <p>The <code>Bootstrap</code> service is a temporary, short-lived containerized component responsible for generating secret shares. Each unit registers with the manager, performs its task, and unregisters before being terminated, minimizing exposure and ensuring secure creation of sensitive cryptographic material.</p> <p>Finally, the <code>Manager\u2019s Postgres Database</code> maintains system state and stores user information such as password verifiers, salts, and metadata about secret shares. This database is only accessed by the manager and is never exposed externally, ensuring centralized and secure management of all critical data.</p> <p>The server-side infrastructure was designed using a distributed trust model. Multiple servers each hold a distinct share of the decryption key, and cooperation among them is required to perform decryption operations. However, the system is intentionally configured so that the servers collectively remain one share short of fully reconstructing the secret. This means that even if all servers are compromised, they cannot independently recover user data. Only the user, who holds the final share, can complete the reconstruction process and regain access to the secret. This design ensures that ultimate control remains with the user while significantly reducing the risks of server-side compromise.</p> <p>For the purposes of this project, we use Docker containers to conveniently run a full-scale system on a single machine. In a real-world deployment, these services would run on physically distributed servers to maximize security and reliability.</p>"},{"location":"design_implementation/#implementation-details","title":"Implementation Details","text":"<p>The user can do the following operations: Registration, Secret Storage and Secret retrieval The following are details of each of these operations \u201cbehind the scenes\".</p>"},{"location":"design_implementation/#user-registration-flow","title":"User Registration Flow","text":"<p>The registration process establishes both authentication credentials and the cryptographic foundation for secure secret storage. It proceeds as follows:</p> <p></p> <ol> <li>The user begins registration by sending to the manager:<ul> <li>Their public end-to-end encryption key (used to protect the user\u2019s own share).</li> <li>Their SRP username, verifier, and salt (pre-computed locally from their password).</li> </ul> </li> <li>The manager:<ul> <li>Stores the received SRP verifier and salt in its DB. Since only the verifier and salt are stored, the manager never learns or stores the plaintext password, ensuring resilience against credential theft.</li> <li>Deploys a short-lived bootstrap service.</li> <li>Sends it a list of public keys and requests it to generate decryption key shares.</li> </ul> </li> <li>The bootstrap:<ul> <li>Uses threshold cryptography to generate encryption key and decryption key shares</li> <li>Encrypts each share with the corresponding recipient\u2019s public key, ensuring that only the intended party can access their share.</li> <li>Encrypts the encryption key with the user\u2019s public key.</li> <li>Sends all to the manager.</li> <li>Destroys itself.</li> </ul> </li> <li>The manager forwards each encrypted share to its respective share server and the user.</li> <li>Each share server and the user store their encrypted share locally.</li> </ol> <p>At the end of registration flow, the system has: - Stored the user\u2019s SRP credentials for future authentication. - Securely distributed encrypted shares across the share servers and the user. - Removed the bootstrap service to ensure no long-lived component retains sensitive material.</p>"},{"location":"design_implementation/#user-secret-storage-flow","title":"User Secret Storage Flow","text":"<p>After completing registration, a user can securely store secrets in the system. This flow ensures that the manager only persists encrypted data and never learns the secret\u2019s plaintext.</p> <p></p> <ol> <li>The user first authenticates against the manager using the SRP protocol with the password established during registration. This step ensures that only the rightful user can request secret storage.</li> <li>As part of the registration process, the user received a public encryption key from the manager.<ul> <li>The user encrypts the secret locally with this key.</li> <li>The user sends the encrypted secret to the manager, along with the <code>user_id</code> and the <code>secret_id</code>. Since the encryption was performed locally, the manager cannot access or derive the plaintext.</li> </ul> </li> <li>The manager stores the encrypted secret in its DB.</li> </ol> <p>At the end of this flow, the secret is durably stored in the manager\u2019s database. Because the manager only handles ciphertext, confidentiality is preserved even in the event of a database compromise.</p>"},{"location":"design_implementation/#user-secret-retrieval-flow","title":"User Secret Retrieval Flow","text":"<p>The retrieval flow ensures that secrets can only be reconstructed by the legitimate user, leveraging threshold cryptography and SRP-based authentication.</p> <p></p> <ol> <li>The user first authenticates against the manager using the SRP protocol with the password established during registration. This step ensures that only the rightful user can request secret retrieval.</li> <li>The user sends the manager the <code>user_id</code> and the <code>secret_id</code> corresponding to the stored secret.</li> <li>The manager retrieves the encrypted secret from its DB. 4.<ul> <li>The manager sends the encrypted secret to all the registered share servers.</li> <li>Each share server uses its locally stored secret share to produce a partially decrypted secret corresponding to the requested secret.</li> <li>Each share server encrypts the partial decryption with the user's public key.</li> <li>Each share server returns its partial decryption to the manager.</li> </ul> </li> <li>The manager sends all the partial decryptions and the encrypted secret to the user. Importantly, the manager does not possess the ability to complete the reconstruction on its own \u2014 it can only serve as a coordinator.</li> <li>The user produces its own partial decryption using its locally stored share, and combines it with the partial decryptions received from the share servers to fully reconstruct the original secret.</li> </ol>"},{"location":"evaluation/","title":"Evaluation","text":"<p>We chose to present latency and throughput graphs to clearly illustrate the system\u2019s performance under varying load and configurations. These graphs allow us to analyze how operations scale with the number of requests and share servers, highlighting bottlenecks, system limits, and the trade-offs between distributed security and operational efficiency.</p>"},{"location":"evaluation/#evaluation-setup","title":"Evaluation Setup","text":"<p>The evaluation was carried out on a MacBook Air equipped with an Apple M2 processor and 8 logical CPUs, with the system running inside a Colima-managed Docker VM. Latency and throughput were measured as functions of the number of system requests, and the results are presented across several configurations with 0, 2, 4, and 8 share servers.</p>"},{"location":"evaluation/#evaluation-results","title":"Evaluation Results","text":"<p>These graphs reveal several important trends:</p> <ol> <li> <p>Retrieval throughput decreases as the number of share servers grows. This is expected, since the retrieval operation requires interaction with all share servers, and increasing their number introduces more communication overhead.</p> </li> <li> <p>Storage throughput remains approximately constant regardless of the number of share servers. This aligns with our design, as storage is handled almost exclusively by the manager service and does not require cooperation from the share servers.</p> </li> <li> <p>Retrieval operations are consistently slower than storage operations in both latency and throughput. This is explained by the fact that retrieval requires coordination with multiple share servers, while storage does not.</p> </li> <li> <p>Throughput quickly saturates around 10 concurrent requests. This plateau is an artifact of the environment: with only 8 logical CPUs available, parallel execution is limited by the underlying hardware. On systems with more CPU capacity, we expect higher throughput scalability.</p> </li> <li> <p>Latency grows linearly, even in the region where throughput is still ramping up. This behavior can be explained by queuing effects: as more requests arrive concurrently, they start to wait for CPU or I/O resources, leading to steadily increasing per-request latency, even before the system has fully reached its maximum throughput.</p> </li> <li> <p>Operation times remain practical for end users. Even under peak load on this constrained hardware setup, the worst-case latency observed was around 8 seconds. This is a reasonable waiting time for a user, especially given that the system was stress-tested on a relatively weak machine.</p> </li> </ol>"},{"location":"evaluation/#evaluation-summary","title":"Evaluation Summary","text":"<p>Overall, the observed performance trends validate the system\u2019s design: storage operations remain lightweight and manager-centric, while retrieval operations naturally incur higher overhead due to their distributed nature. The throughput saturation highlights hardware limitations rather than architectural flaws, suggesting that on more powerful environments the system could scale further. This trade-off between performance and distributed security guarantees appears to be well balanced for the intended use case.</p>"},{"location":"how_to_run/","title":"How to Run Vault","text":"<p>This guide provides step-by-step instructions to set up and run the Vault system using Docker. The setup involves multiple services, including the Manager, Bootstrap, Share Servers, and Client.</p>"},{"location":"how_to_run/#installation","title":"Installation","text":"<ol> <li> <p>Clone the Vault repository:    <pre><code>git clone https://github.com/jonco5555/vault.git\ncd vault\n</code></pre></p> </li> <li> <p>Install:</p> uvdockerdocker-compose <pre><code>uv sync\n</code></pre> <pre><code>docker build -t vault .\n</code></pre> <pre><code>docker-compose build\n</code></pre> </li> </ol>"},{"location":"how_to_run/#running-the-system","title":"Running the System","text":"uvdockerdocker-compose <pre><code>uv run vault --help\n</code></pre> <pre><code>docker run vault vault --help\n</code></pre> <pre><code>docker-compose up\n</code></pre>"},{"location":"how_to_run/#full-example","title":"Full Example","text":"<pre><code>chmod +x ./run_test_case.sh\n./run_test_case.sh\n</code></pre>"},{"location":"how_to_run/#running-evaluation","title":"Running Evaluation","text":"<pre><code>uv run ./evaluation/run_evaluation.py\n</code></pre>"},{"location":"assets/mermaid/authentication.mermaid/","title":"Authentication.mermaid","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Server\n\n    opt Registration\n        Note over Client: Choosing a Username and asecret password.&lt;br/&gt;generating a password verifier and a salt.\n        Client -&gt;&gt; Server: AuthRegister (username, verifier, salt)\n        Note over Server: Store verifier and a salt.\n    end\n\n\n    opt Secure call\n        Note over Client,Server: First do the SRP handshake and verification.\n        Client -&gt;&gt; Server: SecureCall::SRPFirstStep (username)\n        Server -&gt;&gt; Client: SecureCall::SRPSecondStep (server_public, salt)\n        Client -&gt;&gt; Server: SecureCall::SRPThirdStep (client_public, client_session_key_proof)\n        Server -&gt;&gt; Client: SecureCall::SRPThirdStepAck (is_authenticated)\n\n        Note over Client,Server: Authenticated, now we can make a grpc call.\n        Client -&gt;&gt; Server: SecureCall::AppRequest\n        Server -&gt;&gt; Client: SecureCall::AppResponse\n    end</code></pre>"},{"location":"assets/mermaid/setup.mermaid/","title":"Setup.mermaid","text":"<pre><code>sequenceDiagram\n        participant SetupMaster\n        participant SetupUnit\n\n        SetupMaster --&gt;&gt; SetupUnit: SetupMaster creates SetupUnit's docker\n        Note over SetupMaster: SetupMaster waits for SetupUnit to&lt;br/&gt;register with `SetupRegister` call\n\n        SetupUnit -&gt;&gt; SetupMaster: SetupRegister (grpc)\n\n        Note over SetupUnit: SetupUnit can do any server work&lt;br/&gt;until `Terminate` call\n\n        Note over SetupMaster: When SetupMaster want to terminate SetupUnit&lt;br/&gt;it sends `Terminate` call and waits for&lt;br/&gt;`SetupUnregister` call\n\n        SetupMaster -&gt;&gt; SetupUnit: Terminate (grpc)\n        Note over SetupUnit: SetupUnit starting gracefull termination that&lt;br/&gt;will end with `SetupUnregister` call\n        SetupUnit -&gt;&gt; SetupMaster: SetupUnregister (grpc)</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>vault<ul> <li>bootstrap<ul> <li>bootstrap</li> </ul> </li> <li>cli</li> <li>common<ul> <li>docker_utils</li> <li>generated<ul> <li>setup_pb2</li> <li>setup_pb2_grpc</li> <li>vault_pb2</li> <li>vault_pb2_grpc</li> </ul> </li> <li>setup_unit</li> <li>types</li> </ul> </li> <li>crypto<ul> <li>asymmetric</li> <li>authentication</li> <li>certs</li> <li>threshold</li> </ul> </li> <li>manager<ul> <li>db_manager</li> <li>manager</li> <li>setup_master</li> </ul> </li> <li>share_server<ul> <li>share_server</li> </ul> </li> <li>user<ul> <li>evaluation</li> <li>user</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/vault/","title":"vault","text":""},{"location":"reference/vault/cli/","title":"cli","text":""},{"location":"reference/vault/bootstrap/","title":"bootstrap","text":""},{"location":"reference/vault/bootstrap/bootstrap/","title":"bootstrap","text":""},{"location":"reference/vault/bootstrap/bootstrap/#vault.bootstrap.bootstrap.Bootstrap","title":"<code>Bootstrap</code>","text":"<p>               Bases: <code>BootstrapServicer</code></p> <p>Bootstrap service for managing the generation of key shares.</p> Source code in <code>src/vault/bootstrap/bootstrap.py</code> <pre><code>class Bootstrap(BootstrapServicer):\n    \"\"\"Bootstrap service for managing the generation of key shares.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        port: int,\n        ca_cert_path: str = \"certs/ca.crt\",\n        ca_key_path: str = \"certs/ca.key\",\n    ):\n        self._logger = logging.getLogger(__class__.__name__)\n        self._port = port\n        self._cert, self._ssl_privkey = generate_component_cert_and_key(\n            name=name,\n            ca_cert_path=ca_cert_path,\n            ca_key_path=ca_key_path,\n        )\n        self._ca_cert = load_ca_cert(ca_cert_path)\n\n        # grpc server\n        self._server_creds = grpc.ssl_server_credentials(\n            [(self._ssl_privkey, self._cert)]\n        )\n        self._client_creds = grpc.ssl_channel_credentials(\n            root_certificates=self._ca_cert\n        )\n        self._server = grpc.aio.server()\n        add_BootstrapServicer_to_server(self, self._server)\n        self._port = self._server.add_secure_port(\n            f\"[::]:{self._port}\", self._server_creds\n        )\n\n    async def start(self):\n        \"\"\"\n        Starts the Bootstrap gRPC server.\n\n        Returns:\n            None\n        \"\"\"\n        await self._server.start()\n        self._logger.info(f\"Bootstrap server started on port {self._port}\")\n\n    async def close(self):\n        \"\"\"\n        Stops the Bootstrap gRPC server.\n\n        Returns:\n            None\n        \"\"\"\n        if self._server:\n            await self._server.stop(grace=5.0)\n        self._logger.info(\"Bootstrap server stopped\")\n\n    async def GenerateShares(self, request, context):\n        \"\"\"\n        Handles the GenerateShares gRPC request to generate and encrypt key shares.\n\n        This method generates a threshold encryption key and splits it into shares.\n        Each share is encrypted with the corresponding public key from the request.\n        The final encryption key is encrypted with the user's public key.\n\n        Args:\n            request: The gRPC request containing threshold, num_of_shares, and public_keys.\n            context: The gRPC context for error handling and status reporting.\n\n        Returns:\n            GenerateSharesResponse: Contains the encrypted shares and encrypted key.\n        \"\"\"\n        self._logger.info(\"Bootstrap generating shares!\")\n        encryption_key, shares = generate_key_and_shares(\n            request.threshold, request.num_of_shares\n        )\n        if len(shares) != len(request.public_keys):\n            context.set_code(grpc.StatusCode.INVALID_ARGUMENT)\n            context.set_details(\n                \"Number of public keys must match number of shares requested\"\n            )\n            return GenerateSharesResponse()\n\n        encrypted_shares = [\n            encrypt(share.model_dump_json().encode(), pub_key)\n            for share, pub_key in zip(shares, request.public_keys)\n        ]\n        encrypted_key = encrypt(\n            encryption_key.model_dump_json().encode(), request.public_keys.pop()\n        )  # The last key is the user's key\n        return GenerateSharesResponse(\n            encrypted_shares=encrypted_shares, encrypted_key=encrypted_key\n        )\n</code></pre>"},{"location":"reference/vault/bootstrap/bootstrap/#vault.bootstrap.bootstrap.Bootstrap.GenerateShares","title":"<code>GenerateShares(request, context)</code>  <code>async</code>","text":"<p>Handles the GenerateShares gRPC request to generate and encrypt key shares.</p> <p>This method generates a threshold encryption key and splits it into shares. Each share is encrypted with the corresponding public key from the request. The final encryption key is encrypted with the user's public key.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <p>The gRPC request containing threshold, num_of_shares, and public_keys.</p> required <code>context</code> <p>The gRPC context for error handling and status reporting.</p> required <p>Returns:</p> Name Type Description <code>GenerateSharesResponse</code> <p>Contains the encrypted shares and encrypted key.</p> Source code in <code>src/vault/bootstrap/bootstrap.py</code> <pre><code>async def GenerateShares(self, request, context):\n    \"\"\"\n    Handles the GenerateShares gRPC request to generate and encrypt key shares.\n\n    This method generates a threshold encryption key and splits it into shares.\n    Each share is encrypted with the corresponding public key from the request.\n    The final encryption key is encrypted with the user's public key.\n\n    Args:\n        request: The gRPC request containing threshold, num_of_shares, and public_keys.\n        context: The gRPC context for error handling and status reporting.\n\n    Returns:\n        GenerateSharesResponse: Contains the encrypted shares and encrypted key.\n    \"\"\"\n    self._logger.info(\"Bootstrap generating shares!\")\n    encryption_key, shares = generate_key_and_shares(\n        request.threshold, request.num_of_shares\n    )\n    if len(shares) != len(request.public_keys):\n        context.set_code(grpc.StatusCode.INVALID_ARGUMENT)\n        context.set_details(\n            \"Number of public keys must match number of shares requested\"\n        )\n        return GenerateSharesResponse()\n\n    encrypted_shares = [\n        encrypt(share.model_dump_json().encode(), pub_key)\n        for share, pub_key in zip(shares, request.public_keys)\n    ]\n    encrypted_key = encrypt(\n        encryption_key.model_dump_json().encode(), request.public_keys.pop()\n    )  # The last key is the user's key\n    return GenerateSharesResponse(\n        encrypted_shares=encrypted_shares, encrypted_key=encrypted_key\n    )\n</code></pre>"},{"location":"reference/vault/bootstrap/bootstrap/#vault.bootstrap.bootstrap.Bootstrap.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Stops the Bootstrap gRPC server.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>src/vault/bootstrap/bootstrap.py</code> <pre><code>async def close(self):\n    \"\"\"\n    Stops the Bootstrap gRPC server.\n\n    Returns:\n        None\n    \"\"\"\n    if self._server:\n        await self._server.stop(grace=5.0)\n    self._logger.info(\"Bootstrap server stopped\")\n</code></pre>"},{"location":"reference/vault/bootstrap/bootstrap/#vault.bootstrap.bootstrap.Bootstrap.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Starts the Bootstrap gRPC server.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>src/vault/bootstrap/bootstrap.py</code> <pre><code>async def start(self):\n    \"\"\"\n    Starts the Bootstrap gRPC server.\n\n    Returns:\n        None\n    \"\"\"\n    await self._server.start()\n    self._logger.info(f\"Bootstrap server started on port {self._port}\")\n</code></pre>"},{"location":"reference/vault/common/","title":"common","text":""},{"location":"reference/vault/common/docker_utils/","title":"docker_utils","text":""},{"location":"reference/vault/common/docker_utils/#vault.common.docker_utils.get_container_address","title":"<code>get_container_address(container_id)</code>","text":"<p>Get the IP address of a Docker container by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>container_id</code> <code>str</code> <p>The container ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The IP address of the container.</p> Source code in <code>src/vault/common/docker_utils.py</code> <pre><code>def get_container_address(container_id: str) -&gt; str:\n    \"\"\"\n    Get the IP address of a Docker container by its ID.\n\n    Args:\n        container_id (str): The container ID.\n\n    Returns:\n        str: The IP address of the container.\n    \"\"\"\n    client = docker.DockerClient(base_url=f\"unix:/{DOCKER_RUNTIME_SOCKET}\")\n    container = client.containers.get(container_id)\n    networks = container.attrs[\"NetworkSettings\"][\"Networks\"]\n    return next(iter(networks.values()))[\"IPAddress\"]\n</code></pre>"},{"location":"reference/vault/common/docker_utils/#vault.common.docker_utils.get_container_name","title":"<code>get_container_name(container_id)</code>","text":"<p>Get the name of a Docker container by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>container_id</code> <code>str</code> <p>The container ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the container.</p> Source code in <code>src/vault/common/docker_utils.py</code> <pre><code>def get_container_name(container_id: str) -&gt; str:\n    \"\"\"\n    Get the name of a Docker container by its ID.\n\n    Args:\n        container_id (str): The container ID.\n\n    Returns:\n        str: The name of the container.\n    \"\"\"\n    client = docker.DockerClient(base_url=f\"unix:/{DOCKER_RUNTIME_SOCKET}\")\n    container = client.containers.get(container_id)\n    return container.name\n</code></pre>"},{"location":"reference/vault/common/docker_utils/#vault.common.docker_utils.get_self_container_id","title":"<code>get_self_container_id()</code>","text":"<p>Get the container ID of the current Docker container. Should be called only when running inside Docker.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The container ID.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If not running inside Docker or if hostname command fails.</p> Source code in <code>src/vault/common/docker_utils.py</code> <pre><code>def get_self_container_id() -&gt; str:\n    \"\"\"\n    Get the container ID of the current Docker container.\n    Should be called only when running inside Docker.\n\n    Returns:\n        str: The container ID.\n\n    Raises:\n        RuntimeError: If not running inside Docker or if hostname command fails.\n    \"\"\"\n    if not _running_in_docker():\n        raise RuntimeError(\"Should be running inside a docker scope\")\n\n    result = subprocess.run([\"hostname\"], capture_output=True, text=True)\n    if 0 != result.returncode:\n        raise RuntimeError(f\"Got errorcode {result.returncode}\")\n    return str(result.stdout)[:-1]  # no new line\n</code></pre>"},{"location":"reference/vault/common/docker_utils/#vault.common.docker_utils.remove_container","title":"<code>remove_container(container_id)</code>","text":"<p>Remove a Docker container by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>container_id</code> <code>str</code> <p>The container ID.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>src/vault/common/docker_utils.py</code> <pre><code>def remove_container(container_id: str):\n    \"\"\"\n    Remove a Docker container by its ID.\n\n    Args:\n        container_id (str): The container ID.\n\n    Returns:\n        None\n    \"\"\"\n    client = docker.from_env()\n    container = client.containers.get(container_id)\n    container.remove(force=False)\n</code></pre>"},{"location":"reference/vault/common/docker_utils/#vault.common.docker_utils.spawn_container","title":"<code>spawn_container(image_name, image_tag='latest', container_name=None, command=None, network=None, environment=None)</code>","text":"<p>Spawn a Docker container with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>image_name</code> <code>str</code> <p>Name of the Docker image.</p> required <code>image_tag</code> <code>str</code> <p>Tag of the Docker image. Defaults to \"latest\".</p> <code>'latest'</code> <code>container_name</code> <code>Optional[str]</code> <p>Name for the container. Defaults to None.</p> <code>None</code> <code>command</code> <code>Optional[str]</code> <p>Command to run in the container. Defaults to None.</p> <code>None</code> <code>network</code> <code>Optional[str]</code> <p>Docker network to connect to. Defaults to None.</p> <code>None</code> <code>environment</code> <code>Optional[dict[str, str]]</code> <p>Environment variables for the container. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>docker.models.containers.Container: The spawned container object.</p> Source code in <code>src/vault/common/docker_utils.py</code> <pre><code>def spawn_container(\n    image_name: str,\n    image_tag: str = \"latest\",\n    container_name: Optional[str] = None,\n    command: Optional[str] = None,\n    network: Optional[str] = None,\n    environment: Optional[dict[str, str]] = None,\n):\n    \"\"\"\n    Spawn a Docker container with the specified parameters.\n\n    Args:\n        image_name (str): Name of the Docker image.\n        image_tag (str, optional): Tag of the Docker image. Defaults to \"latest\".\n        container_name (Optional[str], optional): Name for the container. Defaults to None.\n        command (Optional[str], optional): Command to run in the container. Defaults to None.\n        network (Optional[str], optional): Docker network to connect to. Defaults to None.\n        environment (Optional[dict[str, str]], optional): Environment variables for the container. Defaults to None.\n\n    Returns:\n        docker.models.containers.Container: The spawned container object.\n    \"\"\"\n    client = docker.from_env()\n\n    # Run a container from the image\n    container = client.containers.run(\n        f\"{image_name}:{image_tag}\",  # image name\n        name=container_name,\n        command=command,\n        detach=True,  # run in background\n        volumes=VOLUMES,\n        network=network,\n        environment=environment,\n    )\n\n    return container\n</code></pre>"},{"location":"reference/vault/common/docker_utils/#vault.common.docker_utils.wait_for_container_to_stop","title":"<code>wait_for_container_to_stop(container_id, timeout=None)</code>  <code>async</code>","text":"<p>Wait asynchronously for a Docker container to stop.</p> <p>Parameters:</p> Name Type Description Default <code>container_id</code> <code>str</code> <p>The container ID.</p> required <code>timeout</code> <code>float | None</code> <p>Timeout in seconds. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>dict | None: Result from container.wait() if stopped, None if timeout.</p> Source code in <code>src/vault/common/docker_utils.py</code> <pre><code>async def wait_for_container_to_stop(container_id: str, timeout: float | None = None):\n    \"\"\"\n    Wait asynchronously for a Docker container to stop.\n\n    Args:\n        container_id (str): The container ID.\n        timeout (float | None, optional): Timeout in seconds. Defaults to None.\n\n    Returns:\n        dict | None: Result from container.wait() if stopped, None if timeout.\n    \"\"\"\n    client = docker.from_env()\n    container = client.containers.get(container_id)\n\n    async def _wait():\n        return await asyncio.to_thread(container.wait)  # non-blocking\n\n    try:\n        result = await asyncio.wait_for(_wait(), timeout=timeout)\n        print(f\"Container {container_id} stopped with:\", result)\n        return result\n    except asyncio.TimeoutError:\n        print(f\"Timeout while waiting for {container_id} to stop\")\n        return None\n</code></pre>"},{"location":"reference/vault/common/setup_unit/","title":"setup_unit","text":""},{"location":"reference/vault/common/types/","title":"types","text":""},{"location":"reference/vault/common/generated/","title":"generated","text":""},{"location":"reference/vault/common/generated/setup_pb2/","title":"setup_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"reference/vault/common/generated/setup_pb2_grpc/","title":"setup_pb2_grpc","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"reference/vault/common/generated/setup_pb2_grpc/#vault.common.generated.setup_pb2_grpc.SetupMaster","title":"<code>SetupMaster</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/setup_pb2_grpc.py</code> <pre><code>class SetupMaster(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    @staticmethod\n    def SetupRegister(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/vault.SetupMaster/SetupRegister',\n            setup__pb2.SetupRegisterRequest.SerializeToString,\n            setup__pb2.SetupRegisterResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n\n    @staticmethod\n    def SetupUnregister(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/vault.SetupMaster/SetupUnregister',\n            setup__pb2.SetupUnregisterRequest.SerializeToString,\n            setup__pb2.SetupUnregisterResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/setup_pb2_grpc/#vault.common.generated.setup_pb2_grpc.SetupMasterServicer","title":"<code>SetupMasterServicer</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/setup_pb2_grpc.py</code> <pre><code>class SetupMasterServicer(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    def SetupRegister(self, request, context):\n        \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def SetupUnregister(self, request, context):\n        \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/setup_pb2_grpc/#vault.common.generated.setup_pb2_grpc.SetupMasterServicer.SetupRegister","title":"<code>SetupRegister(request, context)</code>","text":"<p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/setup_pb2_grpc.py</code> <pre><code>def SetupRegister(self, request, context):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/setup_pb2_grpc/#vault.common.generated.setup_pb2_grpc.SetupMasterServicer.SetupUnregister","title":"<code>SetupUnregister(request, context)</code>","text":"<p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/setup_pb2_grpc.py</code> <pre><code>def SetupUnregister(self, request, context):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/setup_pb2_grpc/#vault.common.generated.setup_pb2_grpc.SetupMasterStub","title":"<code>SetupMasterStub</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/setup_pb2_grpc.py</code> <pre><code>class SetupMasterStub(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    def __init__(self, channel):\n        \"\"\"Constructor.\n\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\n        self.SetupRegister = channel.unary_unary(\n                '/vault.SetupMaster/SetupRegister',\n                request_serializer=setup__pb2.SetupRegisterRequest.SerializeToString,\n                response_deserializer=setup__pb2.SetupRegisterResponse.FromString,\n                _registered_method=True)\n        self.SetupUnregister = channel.unary_unary(\n                '/vault.SetupMaster/SetupUnregister',\n                request_serializer=setup__pb2.SetupUnregisterRequest.SerializeToString,\n                response_deserializer=setup__pb2.SetupUnregisterResponse.FromString,\n                _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/setup_pb2_grpc/#vault.common.generated.setup_pb2_grpc.SetupMasterStub.__init__","title":"<code>__init__(channel)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <p>A grpc.Channel.</p> required Source code in <code>src/vault/common/generated/setup_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\n    self.SetupRegister = channel.unary_unary(\n            '/vault.SetupMaster/SetupRegister',\n            request_serializer=setup__pb2.SetupRegisterRequest.SerializeToString,\n            response_deserializer=setup__pb2.SetupRegisterResponse.FromString,\n            _registered_method=True)\n    self.SetupUnregister = channel.unary_unary(\n            '/vault.SetupMaster/SetupUnregister',\n            request_serializer=setup__pb2.SetupUnregisterRequest.SerializeToString,\n            response_deserializer=setup__pb2.SetupUnregisterResponse.FromString,\n            _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/setup_pb2_grpc/#vault.common.generated.setup_pb2_grpc.SetupUnit","title":"<code>SetupUnit</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/setup_pb2_grpc.py</code> <pre><code>class SetupUnit(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    @staticmethod\n    def Terminate(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/vault.SetupUnit/Terminate',\n            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/setup_pb2_grpc/#vault.common.generated.setup_pb2_grpc.SetupUnitServicer","title":"<code>SetupUnitServicer</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/setup_pb2_grpc.py</code> <pre><code>class SetupUnitServicer(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    def Terminate(self, request, context):\n        \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/setup_pb2_grpc/#vault.common.generated.setup_pb2_grpc.SetupUnitServicer.Terminate","title":"<code>Terminate(request, context)</code>","text":"<p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/setup_pb2_grpc.py</code> <pre><code>def Terminate(self, request, context):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/setup_pb2_grpc/#vault.common.generated.setup_pb2_grpc.SetupUnitStub","title":"<code>SetupUnitStub</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/setup_pb2_grpc.py</code> <pre><code>class SetupUnitStub(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    def __init__(self, channel):\n        \"\"\"Constructor.\n\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\n        self.Terminate = channel.unary_unary(\n                '/vault.SetupUnit/Terminate',\n                request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n                _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/setup_pb2_grpc/#vault.common.generated.setup_pb2_grpc.SetupUnitStub.__init__","title":"<code>__init__(channel)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <p>A grpc.Channel.</p> required Source code in <code>src/vault/common/generated/setup_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\n    self.Terminate = channel.unary_unary(\n            '/vault.SetupUnit/Terminate',\n            request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,\n            response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,\n            _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2/","title":"vault_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/","title":"vault_pb2_grpc","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.Bootstrap","title":"<code>Bootstrap</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>class Bootstrap(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    @staticmethod\n    def GenerateShares(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/vault.Bootstrap/GenerateShares',\n            vault__pb2.GenerateSharesRequest.SerializeToString,\n            vault__pb2.GenerateSharesResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.BootstrapServicer","title":"<code>BootstrapServicer</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>class BootstrapServicer(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    def GenerateShares(self, request, context):\n        \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.BootstrapServicer.GenerateShares","title":"<code>GenerateShares(request, context)</code>","text":"<p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>def GenerateShares(self, request, context):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.BootstrapStub","title":"<code>BootstrapStub</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>class BootstrapStub(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    def __init__(self, channel):\n        \"\"\"Constructor.\n\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\n        self.GenerateShares = channel.unary_unary(\n                '/vault.Bootstrap/GenerateShares',\n                request_serializer=vault__pb2.GenerateSharesRequest.SerializeToString,\n                response_deserializer=vault__pb2.GenerateSharesResponse.FromString,\n                _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.BootstrapStub.__init__","title":"<code>__init__(channel)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <p>A grpc.Channel.</p> required Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\n    self.GenerateShares = channel.unary_unary(\n            '/vault.Bootstrap/GenerateShares',\n            request_serializer=vault__pb2.GenerateSharesRequest.SerializeToString,\n            response_deserializer=vault__pb2.GenerateSharesResponse.FromString,\n            _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.Manager","title":"<code>Manager</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>class Manager(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    @staticmethod\n    def Register(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/vault.Manager/Register',\n            vault__pb2.RegisterRequest.SerializeToString,\n            vault__pb2.RegisterResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n\n    @staticmethod\n    def SecureCall(request_iterator,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.stream_stream(\n            request_iterator,\n            target,\n            '/vault.Manager/SecureCall',\n            vault__pb2.SecureReqMsgWrapper.SerializeToString,\n            vault__pb2.SecureRespMsgWrapper.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.ManagerServicer","title":"<code>ManagerServicer</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>class ManagerServicer(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    def Register(self, request, context):\n        \"\"\"Register username over SRP protocol and store end-2-end encryption key.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def SecureCall(self, request_iterator, context):\n        \"\"\"Single bidirectional stream: SRP login handshake + authenticated application request/response\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.ManagerServicer.Register","title":"<code>Register(request, context)</code>","text":"<p>Register username over SRP protocol and store end-2-end encryption key.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>def Register(self, request, context):\n    \"\"\"Register username over SRP protocol and store end-2-end encryption key.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.ManagerServicer.SecureCall","title":"<code>SecureCall(request_iterator, context)</code>","text":"<p>Single bidirectional stream: SRP login handshake + authenticated application request/response</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>def SecureCall(self, request_iterator, context):\n    \"\"\"Single bidirectional stream: SRP login handshake + authenticated application request/response\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.ManagerStub","title":"<code>ManagerStub</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>class ManagerStub(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    def __init__(self, channel):\n        \"\"\"Constructor.\n\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\n        self.Register = channel.unary_unary(\n                '/vault.Manager/Register',\n                request_serializer=vault__pb2.RegisterRequest.SerializeToString,\n                response_deserializer=vault__pb2.RegisterResponse.FromString,\n                _registered_method=True)\n        self.SecureCall = channel.stream_stream(\n                '/vault.Manager/SecureCall',\n                request_serializer=vault__pb2.SecureReqMsgWrapper.SerializeToString,\n                response_deserializer=vault__pb2.SecureRespMsgWrapper.FromString,\n                _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.ManagerStub.__init__","title":"<code>__init__(channel)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <p>A grpc.Channel.</p> required Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\n    self.Register = channel.unary_unary(\n            '/vault.Manager/Register',\n            request_serializer=vault__pb2.RegisterRequest.SerializeToString,\n            response_deserializer=vault__pb2.RegisterResponse.FromString,\n            _registered_method=True)\n    self.SecureCall = channel.stream_stream(\n            '/vault.Manager/SecureCall',\n            request_serializer=vault__pb2.SecureReqMsgWrapper.SerializeToString,\n            response_deserializer=vault__pb2.SecureRespMsgWrapper.FromString,\n            _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.ShareServer","title":"<code>ShareServer</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>class ShareServer(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    @staticmethod\n    def StoreShare(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/vault.ShareServer/StoreShare',\n            vault__pb2.StoreShareRequest.SerializeToString,\n            vault__pb2.StoreShareResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n\n    @staticmethod\n    def DeleteShare(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/vault.ShareServer/DeleteShare',\n            vault__pb2.DeleteShareRequest.SerializeToString,\n            vault__pb2.DeleteShareResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n\n    @staticmethod\n    def Decrypt(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(\n            request,\n            target,\n            '/vault.ShareServer/Decrypt',\n            vault__pb2.DecryptRequest.SerializeToString,\n            vault__pb2.DecryptResponse.FromString,\n            options,\n            channel_credentials,\n            insecure,\n            call_credentials,\n            compression,\n            wait_for_ready,\n            timeout,\n            metadata,\n            _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.ShareServerServicer","title":"<code>ShareServerServicer</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>class ShareServerServicer(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    def StoreShare(self, request, context):\n        \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def DeleteShare(self, request, context):\n        \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def Decrypt(self, request, context):\n        \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.ShareServerServicer.Decrypt","title":"<code>Decrypt(request, context)</code>","text":"<p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>def Decrypt(self, request, context):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.ShareServerServicer.DeleteShare","title":"<code>DeleteShare(request, context)</code>","text":"<p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>def DeleteShare(self, request, context):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.ShareServerServicer.StoreShare","title":"<code>StoreShare(request, context)</code>","text":"<p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>def StoreShare(self, request, context):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.ShareServerStub","title":"<code>ShareServerStub</code>","text":"<p>               Bases: <code>object</code></p> <p>Missing associated documentation comment in .proto file.</p> Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>class ShareServerStub(object):\n    \"\"\"Missing associated documentation comment in .proto file.\"\"\"\n\n    def __init__(self, channel):\n        \"\"\"Constructor.\n\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\n        self.StoreShare = channel.unary_unary(\n                '/vault.ShareServer/StoreShare',\n                request_serializer=vault__pb2.StoreShareRequest.SerializeToString,\n                response_deserializer=vault__pb2.StoreShareResponse.FromString,\n                _registered_method=True)\n        self.DeleteShare = channel.unary_unary(\n                '/vault.ShareServer/DeleteShare',\n                request_serializer=vault__pb2.DeleteShareRequest.SerializeToString,\n                response_deserializer=vault__pb2.DeleteShareResponse.FromString,\n                _registered_method=True)\n        self.Decrypt = channel.unary_unary(\n                '/vault.ShareServer/Decrypt',\n                request_serializer=vault__pb2.DecryptRequest.SerializeToString,\n                response_deserializer=vault__pb2.DecryptResponse.FromString,\n                _registered_method=True)\n</code></pre>"},{"location":"reference/vault/common/generated/vault_pb2_grpc/#vault.common.generated.vault_pb2_grpc.ShareServerStub.__init__","title":"<code>__init__(channel)</code>","text":"<p>Constructor.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <p>A grpc.Channel.</p> required Source code in <code>src/vault/common/generated/vault_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\n    self.StoreShare = channel.unary_unary(\n            '/vault.ShareServer/StoreShare',\n            request_serializer=vault__pb2.StoreShareRequest.SerializeToString,\n            response_deserializer=vault__pb2.StoreShareResponse.FromString,\n            _registered_method=True)\n    self.DeleteShare = channel.unary_unary(\n            '/vault.ShareServer/DeleteShare',\n            request_serializer=vault__pb2.DeleteShareRequest.SerializeToString,\n            response_deserializer=vault__pb2.DeleteShareResponse.FromString,\n            _registered_method=True)\n    self.Decrypt = channel.unary_unary(\n            '/vault.ShareServer/Decrypt',\n            request_serializer=vault__pb2.DecryptRequest.SerializeToString,\n            response_deserializer=vault__pb2.DecryptResponse.FromString,\n            _registered_method=True)\n</code></pre>"},{"location":"reference/vault/crypto/","title":"crypto","text":""},{"location":"reference/vault/crypto/asymmetric/","title":"asymmetric","text":""},{"location":"reference/vault/crypto/asymmetric/#vault.crypto.asymmetric.decrypt","title":"<code>decrypt(ciphertext, privkey_b64)</code>","text":"<p>Decrypt a message using the recipient's private key (SealedBox).</p> <p>Parameters:</p> Name Type Description Default <code>ciphertext</code> <code>bytes</code> <p>The encrypted message to decrypt.</p> required <code>privkey_b64</code> <code>bytes</code> <p>The recipient's private key in Base64 format.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The decrypted plaintext message.</p> Source code in <code>src/vault/crypto/asymmetric.py</code> <pre><code>def decrypt(ciphertext: bytes, privkey_b64: bytes) -&gt; bytes:\n    \"\"\"\n    Decrypt a message using the recipient's private key (SealedBox).\n\n    Args:\n        ciphertext (bytes): The encrypted message to decrypt.\n        privkey_b64 (bytes): The recipient's private key in Base64 format.\n\n    Returns:\n        bytes: The decrypted plaintext message.\n    \"\"\"\n    privkey = PrivateKey(privkey_b64, encoder=Base64Encoder)\n    sealed_box = SealedBox(privkey)\n    try:\n        plaintext = sealed_box.decrypt(ciphertext)\n        return plaintext\n    except CryptoError:\n        raise ValueError(\"Decryption failed. Invalid key or corrupted ciphertext.\")\n</code></pre>"},{"location":"reference/vault/crypto/asymmetric/#vault.crypto.asymmetric.encrypt","title":"<code>encrypt(message, pubkey_b64)</code>","text":"<p>Encrypt a message using the recipient's public key (SealedBox).</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>bytes</code> <p>The plaintext message to encrypt.</p> required <code>pubkey_b64</code> <code>bytes</code> <p>The recipient's public key in Base64 format.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The encrypted ciphertext.</p> Source code in <code>src/vault/crypto/asymmetric.py</code> <pre><code>def encrypt(message: bytes, pubkey_b64: bytes) -&gt; bytes:\n    \"\"\"\n    Encrypt a message using the recipient's public key (SealedBox).\n\n    Args:\n        message (bytes): The plaintext message to encrypt.\n        pubkey_b64 (bytes): The recipient's public key in Base64 format.\n\n    Returns:\n        bytes: The encrypted ciphertext.\n    \"\"\"\n    pubkey = PublicKey(pubkey_b64, encoder=Base64Encoder)\n    sealed_box = SealedBox(pubkey)\n    ciphertext = sealed_box.encrypt(message)\n    return ciphertext\n</code></pre>"},{"location":"reference/vault/crypto/asymmetric/#vault.crypto.asymmetric.generate_key_pair","title":"<code>generate_key_pair()</code>","text":"<p>Generate a NaCl key pair and return private and public keys (Base64 encoded).</p> <p>Returns:</p> Type Description <code>Tuple[bytes, bytes]</code> <p>Tuple[bytes, bytes]: Private and public keys, both Base64 encoded.</p> Source code in <code>src/vault/crypto/asymmetric.py</code> <pre><code>def generate_key_pair() -&gt; Tuple[bytes, bytes]:\n    \"\"\"\n    Generate a NaCl key pair and return private and public keys (Base64 encoded).\n\n    Returns:\n        Tuple[bytes, bytes]: Private and public keys, both Base64 encoded.\n    \"\"\"\n    privkey = PrivateKey.generate()\n    pubkey = privkey.public_key\n\n    # Serialize keys as Base64\n    privkey_b64 = privkey.encode(encoder=Base64Encoder)\n    pubkey_b64 = pubkey.encode(encoder=Base64Encoder)\n    return privkey_b64, pubkey_b64\n</code></pre>"},{"location":"reference/vault/crypto/authentication/","title":"authentication","text":""},{"location":"reference/vault/crypto/certs/","title":"certs","text":""},{"location":"reference/vault/crypto/threshold/","title":"threshold","text":""},{"location":"reference/vault/crypto/threshold/#vault.crypto.threshold.decrypt","title":"<code>decrypt(partial_decryptions, secret, threshold, num_of_shares)</code>","text":"<p>Decrypts a secret using a list of partial decryptions and threshold parameters.</p> <p>Parameters:</p> Name Type Description Default <code>partial_decryptions</code> <code>list[PartialDecryption]</code> <p>List of partial decryption results.</p> required <code>secret</code> <code>Secret</code> <p>The encrypted secret to decrypt.</p> required <code>threshold</code> <code>int</code> <p>Minimum number of shares required for decryption.</p> required <code>num_of_shares</code> <code>int</code> <p>Total number of shares.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The decrypted plaintext message.</p> Source code in <code>src/vault/crypto/threshold.py</code> <pre><code>def decrypt(\n    partial_decryptions: list[types.PartialDecryption],\n    secret: Secret,\n    threshold: int,\n    num_of_shares: int,\n) -&gt; str:\n    \"\"\"\n    Decrypts a secret using a list of partial decryptions and threshold parameters.\n\n    Args:\n        partial_decryptions (list[types.PartialDecryption]): List of partial decryption results.\n        secret (Secret): The encrypted secret to decrypt.\n        threshold (int): Minimum number of shares required for decryption.\n        num_of_shares (int): Total number of shares.\n\n    Returns:\n        str: The decrypted plaintext message.\n    \"\"\"\n    threshold_params = tc.ThresholdParameters(t=threshold, n=num_of_shares)\n    decryptions = [\n        tc.PartialDecryption(\n            x=int(pd.x),\n            yC1=EccPoint(int(pd.yc1.x), int(pd.yc1.y)),\n            curve_params=tc.CurveParameters(),\n        )\n        for pd in partial_decryptions\n    ]\n    encrypted_message = EncryptedMessage(\n        EccPoint(int(secret.c1.x), int(secret.c1.y)),\n        EccPoint(int(secret.c2.x), int(secret.c2.y)),\n        secret.ciphertext,\n    )\n    return tc.decrypt_message(decryptions, encrypted_message, threshold_params)\n</code></pre>"},{"location":"reference/vault/crypto/threshold/#vault.crypto.threshold.encrypt","title":"<code>encrypt(message, encryption_key)</code>","text":"<p>Encrypts a message using the provided encryption key.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The plaintext message to encrypt.</p> required <code>encryption_key</code> <code>Key</code> <p>The public encryption key used for encryption.</p> required <p>Returns:</p> Name Type Description <code>Secret</code> <code>Secret</code> <p>An object containing the encrypted message components (C1, C2, ciphertext).</p> Source code in <code>src/vault/crypto/threshold.py</code> <pre><code>def encrypt(message: str, encryption_key: types.Key) -&gt; Secret:\n    \"\"\"\n    Encrypts a message using the provided encryption key.\n\n    Args:\n        message (str): The plaintext message to encrypt.\n        encryption_key (Key): The public encryption key used for encryption.\n\n    Returns:\n        Secret: An object containing the encrypted message components (C1, C2, ciphertext).\n    \"\"\"\n    encrypted_message = tc.encrypt_message(\n        message, PublicKey(EccPoint(int(encryption_key.x), int(encryption_key.y)))\n    )\n    return Secret(\n        c1=pb2.Key(x=str(encrypted_message.C1.x), y=str(encrypted_message.C1.y)),\n        c2=pb2.Key(x=str(encrypted_message.C2.x), y=str(encrypted_message.C2.y)),\n        ciphertext=encrypted_message.ciphertext,\n    )\n</code></pre>"},{"location":"reference/vault/crypto/threshold/#vault.crypto.threshold.generate_key_and_shares","title":"<code>generate_key_and_shares(threshold, num_of_shares)</code>","text":"<p>Generates an encryption key and its threshold shares.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>int</code> <p>The minimum number of shares required to reconstruct the key.</p> required <code>num_of_shares</code> <code>int</code> <p>The total number of shares to generate.</p> required <p>Returns:</p> Type Description <code>tuple[Key, list[Key]]</code> <p>tuple[Key, list[Key]]: A tuple containing the generated encryption key and a list of shares.</p> Source code in <code>src/vault/crypto/threshold.py</code> <pre><code>def generate_key_and_shares(\n    threshold: int, num_of_shares: int\n) -&gt; tuple[types.Key, list[types.Key]]:\n    \"\"\"\n    Generates an encryption key and its threshold shares.\n\n    Args:\n        threshold (int): The minimum number of shares required to reconstruct the key.\n        num_of_shares (int): The total number of shares to generate.\n\n    Returns:\n        tuple[Key, list[Key]]: A tuple containing the generated encryption key and a list of shares.\n    \"\"\"\n    pub_key, key_shares = tc.create_public_key_and_shares_centralized(\n        tc.CurveParameters(), tc.ThresholdParameters(t=threshold, n=num_of_shares)\n    )\n    pub_key: PublicKey\n    key_shares: list[KeyShare]\n    encryption_key = types.Key(x=str(pub_key.Q.x), y=str(pub_key.Q.y))\n    shares = [types.Key(x=str(s.x), y=str(s.y)) for s in key_shares]\n    return encryption_key, shares\n</code></pre>"},{"location":"reference/vault/crypto/threshold/#vault.crypto.threshold.partial_decrypt","title":"<code>partial_decrypt(secret, share)</code>","text":"<p>Performs a partial decryption of a secret using a given share.</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>Secret</code> <p>The encrypted secret to be partially decrypted.</p> required <code>share</code> <code>Key</code> <p>The share (Key) used for partial decryption.</p> required <p>Returns:</p> Type Description <code>PartialDecryption</code> <p>types.PartialDecryption: The result of the partial decryption.</p> Source code in <code>src/vault/crypto/threshold.py</code> <pre><code>def partial_decrypt(secret: Secret, share: types.Key) -&gt; types.PartialDecryption:\n    \"\"\"\n    Performs a partial decryption of a secret using a given share.\n\n    Args:\n        secret (Secret): The encrypted secret to be partially decrypted.\n        share (Key): The share (Key) used for partial decryption.\n\n    Returns:\n        types.PartialDecryption: The result of the partial decryption.\n    \"\"\"\n    partial_decrypted = tc.compute_partial_decryption(\n        EncryptedMessage(\n            EccPoint(int(secret.c1.x), int(secret.c1.y)),\n            EccPoint(int(secret.c2.x), int(secret.c2.y)),\n            secret.ciphertext,\n        ),\n        KeyShare(int(share.x), int(share.y), tc.CurveParameters()),\n    )\n    return types.PartialDecryption(\n        x=str(partial_decrypted.x),\n        yc1=types.Key(x=str(partial_decrypted.yC1.x), y=str(partial_decrypted.yC1.y)),\n    )\n</code></pre>"},{"location":"reference/vault/manager/","title":"manager","text":""},{"location":"reference/vault/manager/db_manager/","title":"db_manager","text":""},{"location":"reference/vault/manager/manager/","title":"manager","text":""},{"location":"reference/vault/manager/manager/#vault.manager.manager.Manager","title":"<code>Manager</code>","text":"<p>               Bases: <code>ManagerServicer</code></p> Source code in <code>src/vault/manager/manager.py</code> <pre><code>class Manager(ManagerServicer):\n    def __init__(\n        self,\n        name: str,\n        port: int,\n        db_host: str,\n        db_port: int,\n        db_username: str,\n        db_password: str,\n        db_name: str,\n        num_of_share_servers: int,\n        setup_master_port: int,\n        setup_unit_port: int,\n        bootstrap_port: int,\n        share_server_port: int,\n        docker_image: str,\n        docker_network: str,\n        bootstrap_command: str,\n        share_server_command: str,\n        ca_cert_path: str = \"certs/ca.crt\",\n        ca_key_path: str = \"certs/ca.key\",\n    ):\n        self._logger = logging.getLogger(__class__.__name__)\n        self._port = port\n        self._name = name\n        self._cert, self._ssl_privkey = generate_component_cert_and_key(\n            name=name,\n            ca_cert_path=ca_cert_path,\n            ca_key_path=ca_key_path,\n        )\n        self._ca_cert = load_ca_cert(ca_cert_path)\n        self._num_of_share_servers = num_of_share_servers\n        self._share_servers_data: List[types.ServiceData] = []\n        self._ready = False\n        self._setup_master_port = setup_master_port\n        self._setup_unit_port = setup_unit_port\n        self._bootstrap_port = bootstrap_port\n        self._share_server_port = share_server_port\n        self._docker_image = docker_image\n        self._docker_network = docker_network\n        self._bootstrap_command = bootstrap_command\n        self._share_server_command = share_server_command\n        self._ca_cert_path = ca_cert_path\n        self._ca_key_path = ca_key_path\n\n        # grpc server\n        self._client_creds = grpc.ssl_channel_credentials(\n            root_certificates=self._ca_cert\n        )\n        creds = grpc.ssl_server_credentials([(self._ssl_privkey, self._cert)])\n        self._server = grpc.aio.server()\n        add_ManagerServicer_to_server(self, self._server)\n        self._port = self._server.add_secure_port(f\"[::]:{self._port}\", creds)\n\n        # DB\n        self._db = DBManager(\n            f\"postgresql+asyncpg://{db_username}:{db_password}@{db_host}:{db_port}/{db_name}\"\n        )\n\n        # Setup master\n        self._setup_master_service: SetupMaster = SetupMaster(\n            port=setup_master_port,\n            setup_unit_port=setup_unit_port,\n            db=self._db,\n            server_creds=creds,\n            client_creds=self._client_creds,\n        )\n\n    async def start(self):\n        await self._db.start()\n        await self._setup_master_service.start()\n\n        await self.launch_all_share_servers()\n\n        await self._server.start()\n        self._ready = True\n        self._logger.info(f\"Server started on port {self._port}\")\n\n    async def stop(self):\n        self._ready = False\n        await self._server.stop(grace=5.0)\n        await self.terminate_all_share_servers()\n\n        # db must live until _setup_master_service dies\n        await self._setup_master_service.stop()\n        await self._db.close()\n        self._logger.info(\"Server stopped\")\n\n    async def Register(self, request: RegisterRequest, context) -&gt; RegisterResponse:\n        self._logger.info(\"Register request for %s\", request.user_id)\n        try:\n            await self._db.add_auth_client(\n                username=request.user_id, verifier=request.verifier, salt=request.salt\n            )\n        except Exception as e:\n            await context.abort(\n                grpc.StatusCode.INTERNAL, f\"SRP registration failed {e}\"\n            )\n            return\n\n        try:\n            return await self._register(request)\n        except RuntimeError as e:\n            await context.abort(\n                grpc.StatusCode.UNKNOWN, f\"_vault_register had error: {e}\"\n            )\n            return\n\n    async def SecureCall(self, request_iterator, context):\n        \"\"\"\n        Bidirectional stream handling:\n        \"\"\"\n        req_iter = request_iterator.__aiter__()\n\n        try:\n            auth_step_1_msg: SecureReqMsgWrapper = await req_iter.__anext__()\n        except StopAsyncIteration:\n            await context.abort(grpc.StatusCode.INVALID_ARGUMENT, \"no messages\")\n            return\n\n        if not auth_step_1_msg or not auth_step_1_msg.HasField(\"auth_step_1\"):\n            await context.abort(\n                grpc.StatusCode.INVALID_ARGUMENT, \"expected auth_step_1\"\n            )\n            return\n\n        username: str = auth_step_1_msg.auth_step_1.username\n        password_verifier: str = await self._db.get_auth_client_verifier(username)\n        salt: str = await self._db.get_auth_client_salt(username)\n\n        server_public, server_private = srp_authentication_server_step_one(\n            username=username,\n            password_verifier=password_verifier,\n        )\n        yield SecureRespMsgWrapper(\n            auth_step_2=SRPSecondStep(\n                server_public_key=server_public,\n                salt=salt,\n            )\n        )\n\n        try:\n            auth_step_3_msg: SecureReqMsgWrapper = await req_iter.__anext__()\n        except StopAsyncIteration:\n            await context.abort(grpc.StatusCode.INVALID_ARGUMENT, \"no auth_step_3\")\n            return\n\n        if not auth_step_3_msg or not auth_step_3_msg.HasField(\"auth_step_3\"):\n            await context.abort(\n                grpc.StatusCode.INVALID_ARGUMENT, \"expected auth_step_3\"\n            )\n            return\n\n        client_public: str = auth_step_3_msg.auth_step_3.client_public_key\n        client_session_key_proof: str = (\n            auth_step_3_msg.auth_step_3.client_session_key_proof\n        )\n\n        _ = srp_authentication_server_step_three(\n            username=username,\n            password_verifier=password_verifier,\n            salt=salt,\n            server_private=server_private,\n            client_public=client_public,\n            client_session_key_proof=client_session_key_proof,\n        )\n\n        yield SecureRespMsgWrapper(\n            auth_step_3_ack=SRPThirdStepAck(\n                ok=True,\n            )\n        )\n\n        try:\n            app_request_msg: SecureReqMsgWrapper = await req_iter.__anext__()\n        except StopAsyncIteration:\n            await context.abort(grpc.StatusCode.INVALID_ARGUMENT, \"expected app_req\")\n            return\n\n        if not app_request_msg or not app_request_msg.HasField(\"app_req\"):\n            await context.abort(grpc.StatusCode.INVALID_ARGUMENT, \"expected app_req\")\n            return\n\n        app_req: InnerRequest = app_request_msg.app_req\n        try:\n            app_resp: InnerResponse = await self._handle_user_inner_request(app_req)\n        except RuntimeError as e:\n            await context.abort(\n                grpc.StatusCode.UNKNOWN, f\"_handle_user_inner_request had error: {e}\"\n            )\n            return\n\n        # Must yield here - otherwise python is mad.\n        yield SecureRespMsgWrapper(app_resp=app_resp)\n\n    async def _handle_user_inner_request(\n        self, inner_request: InnerRequest\n    ) -&gt; InnerResponse:\n        if inner_request.HasField(\"store\"):\n            return InnerResponse(store=await self.store_secret(inner_request.store))\n        elif inner_request.HasField(\"retrieve\"):\n            return InnerResponse(\n                retrieve=await self.retrieve_secret(inner_request.retrieve)\n            )\n        else:\n            raise RuntimeError(\"unknown InnerRequest body type\")\n\n    async def _register(self, request: RegisterRequest) -&gt; RegisterResponse:\n        self._logger.info(f\"Received registration request from user {request.user_id}\")\n\n        self._validate_server_ready()\n        await self._validate_user_not_exists(request.user_id)\n\n        # Add user to DB\n        await self._db.add_user(request.user_id, request.user_public_key)\n\n        # Get public keys of share servers\n        public_keys = await self._db.get_servers_keys()\n        self._validate_num_of_servers_in_db(len(public_keys))\n\n        # Add user's public key to the end of the list, where the bootstrap expects it\n        public_keys.append(request.user_public_key)\n\n        # Create bootstrap\n        bootstrap_server_data = await self._setup_master_service.spawn_server(\n            image=self._docker_image,\n            container_name=f\"vault-bootstrap-{request.user_id}\",\n            command=self._bootstrap_command,\n            network=self._docker_network,\n            environment={\n                \"PORT\": self._bootstrap_port,\n                \"SETUP_UNIT_PORT\": self._setup_unit_port,\n                \"SETUP_MASTER_ADDRESS\": self._name,\n                \"SETUP_MASTER_PORT\": self._setup_master_port,\n                \"CA_CERT_PATH\": self._ca_cert_path,\n                \"CA_KEY_PATH\": self._ca_key_path,\n            },\n        )\n        bootstrap_address = (\n            f\"{bootstrap_server_data.container_name}:{self._bootstrap_port}\"\n        )\n\n        # Sending generate shares request to bootstrap\n        async with grpc.aio.secure_channel(\n            bootstrap_address, self._client_creds\n        ) as channel:\n            stub = BootstrapStub(channel)\n            bootstrap_response: GenerateSharesResponse = await stub.GenerateShares(\n                GenerateSharesRequest(\n                    threshold=self._num_of_share_servers + 1,  # +1 for the user\n                    num_of_shares=self._num_of_share_servers + 1,\n                    public_keys=public_keys,\n                )\n            )\n\n        # terminate bootstrap\n        await self._setup_master_service.terminate_service(bootstrap_server_data)\n\n        # Get user's share, assuming it is the last one\n        user_share = bootstrap_response.encrypted_shares.pop()\n\n        # Send shares to share servers\n        servers_addresses = await self._db.get_servers_addresses()\n        for share, server_address in zip(\n            bootstrap_response.encrypted_shares, servers_addresses\n        ):\n            async with grpc.aio.secure_channel(\n                f\"{server_address}:{self._share_server_port}\", self._client_creds\n            ) as channel:\n                stub = ShareServerStub(channel)\n                share_server_response: StoreShareResponse = await stub.StoreShare(\n                    StoreShareRequest(user_id=request.user_id, encrypted_share=share)\n                )\n                if not share_server_response.success:\n                    self._logger.error(\n                        f\"Failed to store share on server {server_address}\"\n                    )\n\n        # Send to user his share and encryption key\n        return RegisterResponse(\n            encrypted_share=user_share, encrypted_key=bootstrap_response.encrypted_key\n        )\n\n    async def store_secret(self, request: StoreSecretRequest) -&gt; StoreSecretResponse:\n        self._logger.info(\n            f\"Storing secret {request.secret_id} for user {request.user_id}\"\n        )\n        self._validate_server_ready()\n        await self._validate_user_exists(request.user_id)\n        await self._db.add_secret(\n            request.user_id, request.secret_id, request.secret.SerializeToString()\n        )\n        return StoreSecretResponse(success=True)\n\n    async def retrieve_secret(\n        self, request: RetrieveSecretRequest\n    ) -&gt; RetrieveSecretResponse:\n        self._logger.info(\n            f\"Retrieving secret {request.secret_id} for user {request.user_id}\"\n        )\n\n        self._validate_server_ready()\n        await self._validate_user_exists(request.user_id)\n\n        # Get secret from DB\n        bytes_secret = await self._db.get_secret(request.user_id, request.secret_id)\n        if not bytes_secret:\n            raise RuntimeError(\"Secret not found\")\n        secret = Secret()\n        secret.ParseFromString(bytes_secret)\n\n        # Get partial decryptions from share servers\n        servers_addresses = await self._db.get_servers_addresses()\n        encrypted_partial_decryptions: list[bytes] = []\n        for server_address in servers_addresses:\n            async with grpc.aio.secure_channel(\n                f\"{server_address}:{self._share_server_port}\", self._client_creds\n            ) as channel:\n                stub = ShareServerStub(channel)\n                response: DecryptResponse = await stub.Decrypt(\n                    DecryptRequest(\n                        user_id=request.user_id,\n                        secret=secret,\n                        user_public_key=await self._db.get_user_public_key(\n                            request.user_id\n                        ),\n                    )\n                )\n                encrypted_partial_decryptions.append(\n                    response.encrypted_partial_decryption\n                )\n        return RetrieveSecretResponse(\n            encrypted_partial_decryptions=encrypted_partial_decryptions, secret=secret\n        )\n\n    async def launch_all_share_servers(self):\n        environment = {\n            \"PORT\": self._share_server_port,\n            \"SETUP_UNIT_PORT\": self._setup_unit_port,\n            \"SETUP_MASTER_ADDRESS\": self._name,\n            \"SETUP_MASTER_PORT\": self._setup_master_port,\n            \"CA_CERT_PATH\": self._ca_cert_path,\n            \"CA_KEY_PATH\": self._ca_key_path,\n        }\n        for i in range(self._num_of_share_servers):\n            self._logger.info(f\"creating share server number {i}\")\n            self._share_servers_data.append(\n                await self._setup_master_service.spawn_server(\n                    image=self._docker_image,\n                    container_name=f\"vault-share-{i}\",\n                    command=self._share_server_command,\n                    network=self._docker_network,\n                    environment=environment,\n                ),\n            )\n        # TODO: make paralel and by not blocking on each share server and sample the db.\n\n    async def terminate_all_share_servers(self):\n        for share_server_data in self._share_servers_data:\n            self._logger.debug(\n                f\"terminating share server with container id {share_server_data.container_id}\"\n            )\n            await self._setup_master_service.terminate_service(share_server_data)\n        # TODO: make paralel and by not blocking on each share server and sample the db.\n\n    # private methdods\n    def _validate_server_ready(self):\n        if not self._ready:\n            raise RuntimeError(\"Server is not ready to accept requests\")\n\n    async def _validate_user_not_exists(self, user_id):\n        if await self._db.user_exists(user_id):\n            raise RuntimeError(f\"User {user_id} already exists\")\n\n    async def _validate_user_exists(self, user_id):\n        if not await self._db.user_exists(user_id):\n            raise RuntimeError(f\"User {user_id} does not exists\")\n\n    def _validate_num_of_servers_in_db(self, num_in_db: int):\n        if num_in_db != self._num_of_share_servers:\n            raise RuntimeError(\n                f\"Not enough share servers registered. Required: {self._num_of_share_servers}, Available: {num_in_db}\"\n            )\n</code></pre>"},{"location":"reference/vault/manager/manager/#vault.manager.manager.Manager.SecureCall","title":"<code>SecureCall(request_iterator, context)</code>  <code>async</code>","text":"<p>Bidirectional stream handling:</p> Source code in <code>src/vault/manager/manager.py</code> <pre><code>async def SecureCall(self, request_iterator, context):\n    \"\"\"\n    Bidirectional stream handling:\n    \"\"\"\n    req_iter = request_iterator.__aiter__()\n\n    try:\n        auth_step_1_msg: SecureReqMsgWrapper = await req_iter.__anext__()\n    except StopAsyncIteration:\n        await context.abort(grpc.StatusCode.INVALID_ARGUMENT, \"no messages\")\n        return\n\n    if not auth_step_1_msg or not auth_step_1_msg.HasField(\"auth_step_1\"):\n        await context.abort(\n            grpc.StatusCode.INVALID_ARGUMENT, \"expected auth_step_1\"\n        )\n        return\n\n    username: str = auth_step_1_msg.auth_step_1.username\n    password_verifier: str = await self._db.get_auth_client_verifier(username)\n    salt: str = await self._db.get_auth_client_salt(username)\n\n    server_public, server_private = srp_authentication_server_step_one(\n        username=username,\n        password_verifier=password_verifier,\n    )\n    yield SecureRespMsgWrapper(\n        auth_step_2=SRPSecondStep(\n            server_public_key=server_public,\n            salt=salt,\n        )\n    )\n\n    try:\n        auth_step_3_msg: SecureReqMsgWrapper = await req_iter.__anext__()\n    except StopAsyncIteration:\n        await context.abort(grpc.StatusCode.INVALID_ARGUMENT, \"no auth_step_3\")\n        return\n\n    if not auth_step_3_msg or not auth_step_3_msg.HasField(\"auth_step_3\"):\n        await context.abort(\n            grpc.StatusCode.INVALID_ARGUMENT, \"expected auth_step_3\"\n        )\n        return\n\n    client_public: str = auth_step_3_msg.auth_step_3.client_public_key\n    client_session_key_proof: str = (\n        auth_step_3_msg.auth_step_3.client_session_key_proof\n    )\n\n    _ = srp_authentication_server_step_three(\n        username=username,\n        password_verifier=password_verifier,\n        salt=salt,\n        server_private=server_private,\n        client_public=client_public,\n        client_session_key_proof=client_session_key_proof,\n    )\n\n    yield SecureRespMsgWrapper(\n        auth_step_3_ack=SRPThirdStepAck(\n            ok=True,\n        )\n    )\n\n    try:\n        app_request_msg: SecureReqMsgWrapper = await req_iter.__anext__()\n    except StopAsyncIteration:\n        await context.abort(grpc.StatusCode.INVALID_ARGUMENT, \"expected app_req\")\n        return\n\n    if not app_request_msg or not app_request_msg.HasField(\"app_req\"):\n        await context.abort(grpc.StatusCode.INVALID_ARGUMENT, \"expected app_req\")\n        return\n\n    app_req: InnerRequest = app_request_msg.app_req\n    try:\n        app_resp: InnerResponse = await self._handle_user_inner_request(app_req)\n    except RuntimeError as e:\n        await context.abort(\n            grpc.StatusCode.UNKNOWN, f\"_handle_user_inner_request had error: {e}\"\n        )\n        return\n\n    # Must yield here - otherwise python is mad.\n    yield SecureRespMsgWrapper(app_resp=app_resp)\n</code></pre>"},{"location":"reference/vault/manager/setup_master/","title":"setup_master","text":""},{"location":"reference/vault/share_server/","title":"share_server","text":""},{"location":"reference/vault/share_server/share_server/","title":"share_server","text":""},{"location":"reference/vault/user/","title":"user","text":""},{"location":"reference/vault/user/evaluation/","title":"evaluation","text":""},{"location":"reference/vault/user/user/","title":"user","text":""}]}